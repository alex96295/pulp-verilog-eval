{
  "module_name": "fifo_v3",
  "parameters": [
    {
      "name": "FALL_THROUGH",
      "type": "bit",
      "default": "1'b0"
    },
    {
      "name": "DATA_WIDTH",
      "type": "int unsigned",
      "default": "32"
    },
    {
      "name": "DEPTH",
      "type": "int unsigned",
      "default": "8"
    },
    {
      "name": "dtype",
      "type": "type",
      "default": "logic [DATA_WIDTH-1:0]"
    },
    {
      "name": "ADDR_DEPTH",
      "type": "int unsigned",
      "default": "(DEPTH > 1) ? $clog2(DEPTH) : 1"
    }
  ],
  "ports": [
    {
      "name": "clk_i",
      "type": "logic",
      "direction": "input",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "rst_ni",
      "type": "logic",
      "direction": "input",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "flush_i",
      "type": "logic",
      "direction": "input",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "testmode_i",
      "type": "logic",
      "direction": "input",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "full_o",
      "type": "logic",
      "direction": "output",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "empty_o",
      "type": "logic",
      "direction": "output",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "usage_o",
      "type": "logic",
      "direction": "output",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [
        {
          "msb": "ADDR_DEPTH-1",
          "lsb": "0"
        }
      ],
      "unpacked_dims": []
    },
    {
      "name": "data_i",
      "type": null,
      "direction": "input",
      "signed": false,
      "type_ref": "dtype",
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "push_i",
      "type": "logic",
      "direction": "input",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "data_o",
      "type": null,
      "direction": "output",
      "signed": false,
      "type_ref": "dtype",
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "pop_i",
      "type": "logic",
      "direction": "input",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    }
  ],
  "description": {
    "function": "A FIFO module with configurable depth and data width, supporting fall-through operation.",
    "protocols": ""
  },
  "keywords": [
    "FIFO",
    "buffer",
    "fall-through",
    "data storage"
  ],
  "content": {
    "consult": "// Compiled by morty-0.9.0 / 2025-09-19 18:39:45.047186814 +02:00:00\n\nmodule fifo_v3 #(\n    parameter bit          FALL_THROUGH = 1'b0,     parameter int unsigned DATA_WIDTH   = 32,       parameter int unsigned DEPTH        = 8,        parameter type dtype                = logic [DATA_WIDTH-1:0],\n        parameter int unsigned ADDR_DEPTH   = (DEPTH > 1) ? $clog2(DEPTH) : 1\n)(\n    input  logic  clk_i,                input  logic  rst_ni,               input  logic  flush_i,              input  logic  testmode_i,               output logic  full_o,               output logic  empty_o,              output logic  [ADDR_DEPTH-1:0] usage_o,          input  dtype  data_i,               input  logic  push_i,                   output dtype  data_o,               input  logic  pop_i             );\n            localparam int unsigned FifoDepth = (DEPTH > 0) ? DEPTH : 1;\n        logic gate_clock;\n        logic [ADDR_DEPTH - 1:0] read_pointer_n, read_pointer_q, write_pointer_n, write_pointer_q;\n            logic [ADDR_DEPTH:0] status_cnt_n, status_cnt_q;\n        dtype [FifoDepth - 1:0] mem_n, mem_q;\n\n    assign usage_o = status_cnt_q[ADDR_DEPTH-1:0];\n\n    if (DEPTH == 0) begin : gen_pass_through\n        assign empty_o     = ~push_i;\n        assign full_o      = ~pop_i;\n    end else begin : gen_fifo\n        assign full_o       = (status_cnt_q == FifoDepth[ADDR_DEPTH:0]);\n        assign empty_o      = (status_cnt_q == 0) & ~(FALL_THROUGH & push_i);\n    end\n    \n        always_comb begin : read_write_comb\n                read_pointer_n  = read_pointer_q;\n        write_pointer_n = write_pointer_q;\n        status_cnt_n    = status_cnt_q;\n        data_o          = (DEPTH == 0) ? data_i : mem_q[read_pointer_q];\n        mem_n           = mem_q;\n        gate_clock      = 1'b1;\n\n                if (push_i && ~full_o) begin\n                        mem_n[write_pointer_q] = data_i;\n                        gate_clock = 1'b0;\n                                    if (write_pointer_q == FifoDepth[ADDR_DEPTH-1:0] - 1)\n                write_pointer_n = '0;\n            else\n                write_pointer_n = write_pointer_q + 1;\n                        status_cnt_n    = status_cnt_q + 1;\n        end\n\n        if (pop_i && ~empty_o) begin\n                                                if (read_pointer_n == FifoDepth[ADDR_DEPTH-1:0] - 1)\n                read_pointer_n = '0;\n            else\n                read_pointer_n = read_pointer_q + 1;\n                        status_cnt_n   = status_cnt_q - 1;\n        end\n\n                if (push_i && pop_i &&  ~full_o && ~empty_o)\n            status_cnt_n   = status_cnt_q;\n\n                if (FALL_THROUGH && (status_cnt_q == 0) && push_i) begin\n            data_o = data_i;\n            if (pop_i) begin\n                status_cnt_n = status_cnt_q;\n                read_pointer_n = read_pointer_q;\n                write_pointer_n = write_pointer_q;\n            end\n        end\n    end\n\n        always_ff @(posedge clk_i or negedge rst_ni) begin\n        if(~rst_ni) begin\n            read_pointer_q  <= '0;\n            write_pointer_q <= '0;\n            status_cnt_q    <= '0;\n        end else begin\n            if (flush_i) begin\n                read_pointer_q  <= '0;\n                write_pointer_q <= '0;\n                status_cnt_q    <= '0;\n             end else begin\n                read_pointer_q  <= read_pointer_n;\n                write_pointer_q <= write_pointer_n;\n                status_cnt_q    <= status_cnt_n;\n            end\n        end\n    end\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n        if(~rst_ni) begin\n            mem_q <= {FifoDepth{dtype'('0)}};\n        end else if (!gate_clock) begin\n            mem_q <= mem_n;\n        end\n    end\n\ninitial begin                                        \n    depth_0: assert (DEPTH > 0)                            \n      else begin                                       \n        $error(\"[ASSERT FAILED] [%m] %s: %s (%s:%0d)\", \"depth_0\", \"DEPTH must be greater than 0.\", \"/scratch2/aottaviano/rtlgen-explore/mage/pulp-verilog-eval/assets/common_cells/src/fifo_v3.sv\", 5); \n \n      end                                              \n  end                                                  \n\n    full_write: assert property (@(posedge clk_i) disable iff ((!rst_ni) !== '0) (full_o |-> ~push_i))                    \n    else begin                                                                                        \n      $error(\"[ASSERT FAILED] [%m] %s: %s (%s:%0d)\", \"full_write\", \"Trying to push new data although the FIFO is full.\", \"/scratch2/aottaviano/rtlgen-explore/mage/pulp-verilog-eval/assets/common_cells/src/fifo_v3.sv\", 5); \n                                                  \n    end                                                                                               \n\n    empty_read: assert property (@(posedge clk_i) disable iff ((!rst_ni) !== '0) (empty_o |-> ~pop_i))                    \n    else begin                                                                                        \n      $error(\"[ASSERT FAILED] [%m] %s: %s (%s:%0d)\", \"empty_read\", \"Trying to pop data although the FIFO is empty.\", \"/scratch2/aottaviano/rtlgen-explore/mage/pulp-verilog-eval/assets/common_cells/src/fifo_v3.sv\", 5); \n                                                  \n    end                                                                                               \n\nendmodule \n",
    "reuse": "module fifo_v3 #(\n    parameter bit          FALL_THROUGH = 1'b0,     parameter int unsigned DATA_WIDTH   = 32,       parameter int unsigned DEPTH        = 8,        parameter type dtype                = logic [DATA_WIDTH-1:0],\n        parameter int unsigned ADDR_DEPTH   = (DEPTH > 1) ? $clog2(DEPTH) : 1\n)(\n    input  logic  clk_i,                input  logic  rst_ni,               input  logic  flush_i,              input  logic  testmode_i,               output logic  full_o,               output logic  empty_o,              output logic  [ADDR_DEPTH-1:0] usage_o,          input  dtype  data_i,               input  logic  push_i,                   output dtype  data_o,               input  logic  pop_i             );\n            localparam int unsigned FifoDepth = (DEPTH > 0) ? DEPTH : 1;\n        logic gate_clock;\n        logic [ADDR_DEPTH - 1:0] read_pointer_n, read_pointer_q, write_pointer_n, write_pointer_q;\n            logic [ADDR_DEPTH:0] status_cnt_n, status_cnt_q;\n        dtype [FifoDepth - 1:0] mem_n, mem_q;\n\n    assign usage_o = status_cnt_q[ADDR_DEPTH-1:0];\n\n    if (DEPTH == 0) begin : gen_pass_through\n        assign empty_o     = ~push_i;\n        assign full_o      = ~pop_i;\n    end else begin : gen_fifo\n        assign full_o       = (status_cnt_q == FifoDepth[ADDR_DEPTH:0]);\n        assign empty_o      = (status_cnt_q == 0) & ~(FALL_THROUGH & push_i);\n    end\n    \n        always_comb begin : read_write_comb\n                read_pointer_n  = read_pointer_q;\n        write_pointer_n = write_pointer_q;\n        status_cnt_n    = status_cnt_q;\n        data_o          = (DEPTH == 0) ? data_i : mem_q[read_pointer_q];\n        mem_n           = mem_q;\n        gate_clock      = 1'b1;\n\n                if (push_i && ~full_o) begin\n                        mem_n[write_pointer_q] = data_i;\n                        gate_clock = 1'b0;\n                                    if (write_pointer_q == FifoDepth[ADDR_DEPTH-1:0] - 1)\n                write_pointer_n = '0;\n            else\n                write_pointer_n = write_pointer_q + 1;\n                        status_cnt_n    = status_cnt_q + 1;\n        end\n\n        if (pop_i && ~empty_o) begin\n                                                if (read_pointer_n == FifoDepth[ADDR_DEPTH-1:0] - 1)\n                read_pointer_n = '0;\n            else\n                read_pointer_n = read_pointer_q + 1;\n                        status_cnt_n   = status_cnt_q - 1;\n        end\n\n                if (push_i && pop_i &&  ~full_o && ~empty_o)\n            status_cnt_n   = status_cnt_q;\n\n                if (FALL_THROUGH && (status_cnt_q == 0) && push_i) begin\n            data_o = data_i;\n            if (pop_i) begin\n                status_cnt_n = status_cnt_q;\n                read_pointer_n = read_pointer_q;\n                write_pointer_n = write_pointer_q;\n            end\n        end\n    end\n\n        always_ff @(posedge clk_i or negedge rst_ni) begin\n        if(~rst_ni) begin\n            read_pointer_q  <= '0;\n            write_pointer_q <= '0;\n            status_cnt_q    <= '0;\n        end else begin\n            if (flush_i) begin\n                read_pointer_q  <= '0;\n                write_pointer_q <= '0;\n                status_cnt_q    <= '0;\n             end else begin\n                read_pointer_q  <= read_pointer_n;\n                write_pointer_q <= write_pointer_n;\n                status_cnt_q    <= status_cnt_n;\n            end\n        end\n    end\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n        if(~rst_ni) begin\n            mem_q <= {FifoDepth{dtype'('0)}};\n        end else if (!gate_clock) begin\n            mem_q <= mem_n;\n        end\n    end\n\ninitial begin                                        \n    depth_0: assert (DEPTH > 0)                            \n      else begin                                       \n        $error(\"[ASSERT FAILED] [%m] %s: %s (%s:%0d)\", \"depth_0\", \"DEPTH must be greater than 0.\", \"/scratch2/aottaviano/rtlgen-explore/mage/pulp-verilog-eval/assets/common_cells/src/fifo_v3.sv\", 5); \n \n      end                                              \n  end                                                  \n\n    full_write: assert property (@(posedge clk_i) disable iff ((!rst_ni) !== '0) (full_o |-> ~push_i))                    \n    else begin                                                                                        \n      $error(\"[ASSERT FAILED] [%m] %s: %s (%s:%0d)\", \"full_write\", \"Trying to push new data although the FIFO is full.\", \"/scratch2/aottaviano/rtlgen-explore/mage/pulp-verilog-eval/assets/common_cells/src/fifo_v3.sv\", 5); \n                                                  \n    end                                                                                               \n\n    empty_read: assert property (@(posedge clk_i) disable iff ((!rst_ni) !== '0) (empty_o |-> ~pop_i))                    \n    else begin                                                                                        \n      $error(\"[ASSERT FAILED] [%m] %s: %s (%s:%0d)\", \"empty_read\", \"Trying to pop data although the FIFO is empty.\", \"/scratch2/aottaviano/rtlgen-explore/mage/pulp-verilog-eval/assets/common_cells/src/fifo_v3.sv\", 5); \n                                                  \n    end                                                                                               \n\nendmodule"
  }
}