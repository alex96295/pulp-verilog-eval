{
  "module_name": "credit_counter",
  "parameters": [
    {
      "name": "NumCredits",
      "type": "int unsigned",
      "default": "0"
    },
    {
      "name": "InitCreditEmpty",
      "type": "bit",
      "default": "1'b0"
    },
    {
      "name": "InitNumCredits",
      "type": "int unsigned",
      "default": "InitCreditEmpty ? '0 : NumCredits"
    },
    {
      "name": "credit_cnt_t",
      "type": "type",
      "default": "logic [$clog2(NumCredits):0]"
    }
  ],
  "ports": [
    {
      "name": "clk_i",
      "type": "logic",
      "direction": "input",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "rst_ni",
      "type": "logic",
      "direction": "input",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "credit_o",
      "type": null,
      "direction": "output",
      "signed": false,
      "type_ref": "credit_cnt_t",
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "credit_give_i",
      "type": "logic",
      "direction": "input",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "credit_take_i",
      "type": "logic",
      "direction": "input",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "credit_init_i",
      "type": "logic",
      "direction": "input",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "credit_left_o",
      "type": "logic",
      "direction": "output",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "credit_crit_o",
      "type": "logic",
      "direction": "output",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    },
    {
      "name": "credit_full_o",
      "type": "logic",
      "direction": "output",
      "signed": false,
      "type_ref": null,
      "modport": null,
      "packed_dims": [],
      "unpacked_dims": []
    }
  ],
  "description": {
    "function": "Manages a counter of credits with initialization, increment, and decrement capabilities.",
    "protocols": ""
  },
  "keywords": [
    "credit",
    "counter",
    "increment",
    "decrement",
    "reset"
  ],
  "content": {
    "consult": "// Compiled by morty-0.9.0 / 2025-09-16 17:34:16.39719893 +02:00:00\n\n// Copyright 2020 ETH Zurich and University of Bologna.\n// Solderpad Hardware License, Version 0.51, see LICENSE for details.\n// SPDX-License-Identifier: SHL-0.51\n\n// Author: Fabian Schuiki <fschuiki@iis.ee.ethz.ch>\n// Author: Paul Scheffler <paulsc@iis.ee.ethz.ch>\n\n// Copyright 2018, 2021 ETH Zurich and University of Bologna.\n//\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n// SPDX-License-Identifier: SHL-0.51\n//\n// Author: Stefan Mach <smach@iis.ee.ethz.ch>\n// Description: Common register defines for RTL designs\n\n\n\n// Abridged Summary of available FF macros:\n// `FF:      asynchronous active-low reset\n// `FFAR:    asynchronous active-high reset\n// `FFARN:   [deprecated] asynchronous active-low reset\n// `FFSR:    synchronous active-high reset\n// `FFSRN:   synchronous active-low reset\n// `FFNR:    without reset\n// `FFL:     load-enable and asynchronous active-low reset\n// `FFLAR:   load-enable and asynchronous active-high reset\n// `FFLARN:  [deprecated] load-enable and asynchronous active-low reset\n// `FFLARNC: load-enable and asynchronous active-low reset and synchronous active-high clear\n// `FFLSR:   load-enable and synchronous active-high reset\n// `FFLSRN:  load-enable and synchronous active-low reset\n// `FFLNR:   load-enable without reset\n\n\n\n\n\n\n// Flip-Flop with asynchronous active-low reset\n// __q: Q output of FF\n// __d: D input of FF\n// __reset_value: value assigned upon reset\n// (__clk: clock input)\n// (__arst_n: asynchronous reset, active-low)\n\n\n// Flip-Flop with asynchronous active-high reset\n// __q: Q output of FF\n// __d: D input of FF\n// __reset_value: value assigned upon reset\n// __clk: clock input\n// __arst: asynchronous reset, active-high\n\n\n// DEPRECATED - use `FF instead\n// Flip-Flop with asynchronous active-low reset\n// __q: Q output of FF\n// __d: D input of FF\n// __reset_value: value assigned upon reset\n// __clk: clock input\n// __arst_n: asynchronous reset, active-low\n\n\n// Flip-Flop with synchronous active-high reset\n// __q: Q output of FF\n// __d: D input of FF\n// __reset_value: value assigned upon reset\n// __clk: clock input\n// __reset_clk: reset input, active-high\n\n\n// Flip-Flop with synchronous active-low reset\n// __q: Q output of FF\n// __d: D input of FF\n// __reset_value: value assigned upon reset\n// __clk: clock input\n// __reset_n_clk: reset input, active-low\n\n\n// Always-enable Flip-Flop without reset\n// __q: Q output of FF\n// __d: D input of FF\n// __clk: clock input\n\n\n// Flip-Flop with load-enable and asynchronous active-low reset (implicit clock and reset)\n// __q: Q output of FF\n// __d: D input of FF\n// __load: load d value into FF\n// __reset_value: value assigned upon reset\n// (__clk: clock input)\n// (__arst_n: asynchronous reset, active-low)\n\n\n// Flip-Flop with load-enable and asynchronous active-high reset\n// __q: Q output of FF\n// __d: D input of FF\n// __load: load d value into FF\n// __reset_value: value assigned upon reset\n// __clk: clock input\n// __arst: asynchronous reset, active-high\n\n\n// DEPRECATED - use `FFL instead\n// Flip-Flop with load-enable and asynchronous active-low reset\n// __q: Q output of FF\n// __d: D input of FF\n// __load: load d value into FF\n// __reset_value: value assigned upon reset\n// __clk: clock input\n// __arst_n: asynchronous reset, active-low\n\n\n// Flip-Flop with load-enable and synchronous active-high reset\n// __q: Q output of FF\n// __d: D input of FF\n// __load: load d value into FF\n// __reset_value: value assigned upon reset\n// __clk: clock input\n// __reset_clk: reset input, active-high\n\n\n// Flip-Flop with load-enable and synchronous active-low reset\n// __q: Q output of FF\n// __d: D input of FF\n// __load: load d value into FF\n// __reset_value: value assigned upon reset\n// __clk: clock input\n// __reset_n_clk: reset input, active-low\n\n\n// Flip-Flop with load-enable and asynchronous active-low reset and synchronous clear\n// __q: Q output of FF\n// __d: D input of FF\n// __load: load d value into FF\n// __clear: assign reset value into FF\n// __reset_value: value assigned upon reset\n// __clk: clock input\n// __arst_n: asynchronous reset, active-low\n\n\n// Flip-Flop with asynchronous active-low reset and synchronous clear\n// __q: Q output of FF\n// __d: D input of FF\n// __clear: assign reset value into FF\n// __reset_value: value assigned upon reset\n// __clk: clock input\n// __arst_n: asynchronous reset, active-low\n\n\n// Load-enable Flip-Flop without reset\n// __q: Q output of FF\n// __d: D input of FF\n// __load: load d value into FF\n// __clk: clock input\n\n\n\n\n// Copyright lowRISC contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n// Macros and helper code for using assertions.\n//  - Provides default clk and rst options to simplify code\n//  - Provides boiler plate template for common assertions\n\n\n\n\n\n///////////////////\n// Helper macros //\n///////////////////\n\n// helper macro to reduce code clutter, can be used to hide signal defs only used for assertions\n\n\n   \n\n// forcefully enable assertions with ASSERTS_OVERRIDE_ON, overriding any define that turns them off\n\n\n// Converts an arbitrary block of code into a Verilog string\n\n\n// ASSERT_RPT is available to change the reporting mechanism when an assert fails\n\n\n\n///////////////////////////////////////\n// Simple assertion and cover macros //\n///////////////////////////////////////\n\n// Default clk and reset signals used by assertion macros below.\n\n\n\n// Immediate assertion\n// Note that immediate assertions are sensitive to simulation glitches.\n\n\n// Assertion in initial block. Can be used for things like parameter checking.\n\n\n// Assertion in final block. Can be used for things like queues being empty\n// at end of sim, all credits returned at end of sim, state machines in idle\n// at end of sim.\n\n\n// Assert a concurrent property directly.\n// It can be called as a module (or interface) body item.\n\n// Note: Above we use (__rst !== '0) in the disable iff statements instead of\n// (__rst == '1).  This properly disables the assertion in cases when reset is X at\n// the beginning of a simulation. For that case, (reset == '1) does not disable the\n// assertion.\n\n// Assert a concurrent property NEVER happens\n\n\n// Assert that signal has a known value (each bit is either '0' or '1') after reset.\n// It can be called as a module (or interface) body item.\n\n\n//  Cover a concurrent property\n\n\n//////////////////////////////\n// Complex assertion macros //\n//////////////////////////////\n\n// Assert that signal is an active-high pulse with pulse length of 1 clock cycle\n\n\n// Assert that a property is true only when an enable signal is set.  It can be called as a module\n// (or interface) body item.\n\n\n// Assert that signal has a known value (each bit is either '0' or '1') after reset if enable is\n// set.  It can be called as a module (or interface) body item.\n\n\n///////////////////////\n// Assumption macros //\n///////////////////////\n\n// Assume a concurrent property\n\n\n// Assume an immediate property\n\n\n//////////////////////////////////\n// For formal verification only //\n//////////////////////////////////\n\n// Note that the existing set of ASSERT macros specified above shall be used for FPV,\n// thereby ensuring that the assertions are evaluated during DV simulations as well.\n\n// ASSUME_FPV\n// Assume a concurrent property during formal verification only.\n\n\n// ASSUME_I_FPV\n// Assume a concurrent property during formal verification only.\n\n\n// COVER_FPV\n// Cover a concurrent property during formal verification\n\n\n\n // COMMON_CELLS_ASSERTIONS_SVH\n\n\nmodule credit_counter #(\n  parameter int unsigned NumCredits      = 0,\n  /// Whether credit is full or empty on reset\n  parameter bit          InitCreditEmpty = 1'b0,\n  /// Derived parameters *Do not override*\n  parameter int unsigned InitNumCredits  = InitCreditEmpty ? '0 : NumCredits,\n  parameter type         credit_cnt_t    = logic [$clog2(NumCredits):0]\n) (\n  input  logic clk_i,\n  input  logic rst_ni,\n\n  output credit_cnt_t credit_o,\n\n  input  logic credit_give_i,\n  input  logic credit_take_i,\n  input  logic credit_init_i,  // Reinitialize (soft-reset) credit; takes priority\n\n  output logic credit_left_o,\n  output logic credit_crit_o,  // Giving one more credit will fill the credits\n  output logic credit_full_o\n);\n\n  credit_cnt_t credit_d, credit_q;\n  logic increment, decrement;\n\n  assign decrement = credit_take_i & ~credit_give_i;\n  assign increment = ~credit_take_i & credit_give_i;\n\n  always_comb begin\n    credit_d = credit_q;\n    if      (decrement) credit_d = credit_q - 1;\n    else if (increment) credit_d = credit_q + 1;\n  end\n\n      /* synopsys sync_set_reset \"credit_init_i\" */                   \n                                                            \n  always_ff @(posedge (clk_i) or negedge (rst_ni)) begin        \n    if (!rst_ni) begin                                          \n      credit_q <= (InitNumCredits);                                     \n    end else begin                                                \n      if (credit_init_i) begin                                          \n        credit_q <= (InitNumCredits);                                   \n      end else begin                                              \n        credit_q <= (credit_d);                                             \n      end                                                         \n    end                                                           \n  end\n\n  assign credit_o       = credit_q;\n  assign credit_left_o  = (credit_q != '0);\n  assign credit_crit_o  = (credit_q == NumCredits-1);\n  assign credit_full_o  = (credit_q == NumCredits);\n\n  CreditUnderflow: assert property (@(posedge clk_i) disable iff ((!rst_ni) !== '0) not (credit_o == '0 && decrement))                      \n    else begin                                                                                              \n      $error(\"[ASSERT FAILED] [%m] %s: %s (%s:%0d)\", \"CreditUnderflow\", \"\", \"/scratch2/aottaviano/rtlgen-explore/mage/pulp-verilog-eval/assets/common_cells/src/credit_counter.sv\", 5); \n                                                        \n    end                                                                                                     \n\n  CreditOverflow: assert property (@(posedge clk_i) disable iff ((!rst_ni) !== '0) not (credit_o == NumCredits && increment))                      \n    else begin                                                                                              \n      $error(\"[ASSERT FAILED] [%m] %s: %s (%s:%0d)\", \"CreditOverflow\", \"\", \"/scratch2/aottaviano/rtlgen-explore/mage/pulp-verilog-eval/assets/common_cells/src/credit_counter.sv\", 5); \n                                                        \n    end                                                                                                     \n\n\nendmodule\n",
    "reuse": "module credit_counter #(\n  parameter int unsigned NumCredits      = 0,\n  /// Whether credit is full or empty on reset\n  parameter bit          InitCreditEmpty = 1'b0,\n  /// Derived parameters *Do not override*\n  parameter int unsigned InitNumCredits  = InitCreditEmpty ? '0 : NumCredits,\n  parameter type         credit_cnt_t    = logic [$clog2(NumCredits):0]\n) (\n  input  logic clk_i,\n  input  logic rst_ni,\n\n  output credit_cnt_t credit_o,\n\n  input  logic credit_give_i,\n  input  logic credit_take_i,\n  input  logic credit_init_i,  // Reinitialize (soft-reset) credit; takes priority\n\n  output logic credit_left_o,\n  output logic credit_crit_o,  // Giving one more credit will fill the credits\n  output logic credit_full_o\n);\n\n  credit_cnt_t credit_d, credit_q;\n  logic increment, decrement;\n\n  assign decrement = credit_take_i & ~credit_give_i;\n  assign increment = ~credit_take_i & credit_give_i;\n\n  always_comb begin\n    credit_d = credit_q;\n    if      (decrement) credit_d = credit_q - 1;\n    else if (increment) credit_d = credit_q + 1;\n  end\n\n      /* synopsys sync_set_reset \"credit_init_i\" */                   \n                                                            \n  always_ff @(posedge (clk_i) or negedge (rst_ni)) begin        \n    if (!rst_ni) begin                                          \n      credit_q <= (InitNumCredits);                                     \n    end else begin                                                \n      if (credit_init_i) begin                                          \n        credit_q <= (InitNumCredits);                                   \n      end else begin                                              \n        credit_q <= (credit_d);                                             \n      end                                                         \n    end                                                           \n  end\n\n  assign credit_o       = credit_q;\n  assign credit_left_o  = (credit_q != '0);\n  assign credit_crit_o  = (credit_q == NumCredits-1);\n  assign credit_full_o  = (credit_q == NumCredits);\n\n  CreditUnderflow: assert property (@(posedge clk_i) disable iff ((!rst_ni) !== '0) not (credit_o == '0 && decrement))                      \n    else begin                                                                                              \n      $error(\"[ASSERT FAILED] [%m] %s: %s (%s:%0d)\", \"CreditUnderflow\", \"\", \"/scratch2/aottaviano/rtlgen-explore/mage/pulp-verilog-eval/assets/common_cells/src/credit_counter.sv\", 5); \n                                                        \n    end                                                                                                     \n\n  CreditOverflow: assert property (@(posedge clk_i) disable iff ((!rst_ni) !== '0) not (credit_o == NumCredits && increment))                      \n    else begin                                                                                              \n      $error(\"[ASSERT FAILED] [%m] %s: %s (%s:%0d)\", \"CreditOverflow\", \"\", \"/scratch2/aottaviano/rtlgen-explore/mage/pulp-verilog-eval/assets/common_cells/src/credit_counter.sv\", 5); \n                                                        \n    end                                                                                                     \n\n\nendmodule"
  }
}